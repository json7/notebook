#### 闲暇时间整理一份计算机基础中关于 原码 反码 补码方面的文章. 文章中 "汉字(x)"的表示方法类比"y=f(x)"

###### 原码:
计算机一个byte占8bit. eg:11111111, 左边第一位为符号位,如果是正数,则符号位的值为0,如果是负数,则为1.  
这种 一个符号位+7个数值位的表示方法就是原码.原码是很简单而且也很容易被人类大脑理解的一种表示方法.

###### 反码:
1. 正数的反码就是他的本身. 也就是说 00000001 = 反码(00000001)
2. 负数的反码就是符号位保持不变,其余7位取反. 也就是说 11111110 = 反码(10000001)

###### 补码:
1. 正数的补码就是他的本身. 也就是说 00000001 = 补码(00000001)
2. 负数的补码是符号位不变, 其余7位取反, 最后+1. (即在反码的基础上+1).   
也就是说 11111111 = 补码(10000001) = 反码(10000001)+1 = 11111110+1
3. 计算机是用补码方式存储数值信息的


###### 为什么用补码
计算机cpu是没有减法器这个东西的,只有加法器.因为减法和加法本身就是同一个本质.
就先拿一个普通的算式举个例子:  

20-5 <=> 20+(-5),减去一个正数就等价于加上一个负数  
如果我们不用补码,我们就用我们人类容易理解的原码进行运算,那么如下:

00010100 = 二进制(20) //20的二进制原码
10000110 = 二进制(-5) //-5的二进制原码  

二者相加:

00010100 (20)

10000110 (-5)   
———-——  
10011010 (-26)  

很明显 结果是错误的. 当然,如果是两个正数相加是没问题的,但是如果是像上面这样 负数参与运算,那么必须为负数的运算单独设计电路.因此计算机采用了补码的方式解决这个问题.

###### 理解补码
1. 我们可以先从简单的数学问题入手:  
20-17 = 3
20+83 = 103 = 将高位溢出 = 3  
再举个老例子:  
一个大钟,如果时针现在指向12点,现在想让他指向10点,那么可以  
a. 往回播2小时(减法,我们不考虑这种情况,因为cpu不做减法)
b. 往前播10个小时(这是我们要采用的方式,这种方法类似于补码的方法,做的是加法)  

现在的问题比较清楚了,就是如何用一个正数取代一个负数,这里面遵循什么样的规律.继续往下走...

2.同余定理:  
 https://baike.baidu.com/item/%E5%90%8C%E4%BD%99%E5%AE%9A%E7%90%86/1212360?fromtitle=%E5%90%8C%E4%BD%99&fromid=1432545
